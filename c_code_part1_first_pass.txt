/*
 * Pseudo C translation of the first portion of assembly.txt
 * This is a best effort translation of 6502 instructions to
 * C-like pseudocode. Hardware specific operations are
 * represented as memory accesses to absolute addresses.
 * Flags and CPU state are not fully emulated.
 */

#include <stdint.h>
#include <stdbool.h>

// Emulated memory
uint8_t mem[0x10000];

// CPU registers
uint8_t A = 0, X = 0, Y = 0, SP = 0;
uint16_t PC = 0x0010;  // start of routine
bool interrupt_disable = false;

void routine(void) {
    // 0x0010: SEI
    interrupt_disable = true;

    // 0x0011: LDA #$11
    A = 0x11;
    // 0x0013: STA $8002
    mem[0x8002] = A;
    // 0x0016: JMP $8000
    PC = 0x8000; // jump to new location
    // execution would continue from 0x8000
}

void subroutine_0019(void) {
    // 0x0019: TXS
    SP = X;

    // wait for PPU ready
    do {
        // 0x001A: LDA $2002
        A = mem[0x2002];
        // 0x001D: BPL $001A
    } while ((A & 0x80) == 0);
    do {
        // 0x001F: LDA $2002
        A = mem[0x2002];
        // 0x0022: BPL $001F
    } while ((A & 0x80) == 0);

    // 0x0024: LDY #$FE
    Y = 0xFE;
    // 0x0026: LDX #$05
    X = 0x05;

    // scan table at $07D7 for values >= 0x0A
    do {
        // 0x0028: LDA $07D7,X
        A = mem[0x07D7 + X];
        // 0x002B: CMP #$0A
        if (A >= 0x0A) {
            // 0x002D: BCS $003B
            break;
        }
        // 0x002F: DEX
        X--;
        // 0x0030: BPL $0028
    } while ((int8_t)X >= 0);

    // 0x0032: LDA $07FF
    A = mem[0x07FF];
    // 0x0035: CMP #$A5
    if (A != 0xA5) {
        // 0x0037: BNE $003B
        Y = 0xD6; // 0x0039: LDY #$D6
    }

    // 0x003B: JSR $90CC
    // call subroutine at 0x90CC (not translated here)
    // 0x003E: STA $4011
    mem[0x4011] = A;
    // 0x0041: STA $0770
    mem[0x0770] = A;

    // 0x0044: LDA #$A5
    A = 0xA5;
    // 0x0046: STA $07FF
    mem[0x07FF] = A;
    // 0x0049: STA $07A7
    mem[0x07A7] = A;

    // 0x004C: LDA #$0F
    A = 0x0F;
    // 0x004E: STA $4015
    mem[0x4015] = A;
    // 0x0051: LDA #$06
    A = 0x06;
    // 0x0053: STA $2001
    mem[0x2001] = A;

    // 0x0056: JSR $8220 (init sound?)
    // 0x0059: JSR $8E19

    // 0x005C: INC $0774
    mem[0x0774]++;
    // 0x005F: LDA $0778
    A = mem[0x0778];
    // 0x0062: ORA #$80
    A |= 0x80;
    // 0x0064: JSR $8EED
    // 0x0067: JMP $8057
}
