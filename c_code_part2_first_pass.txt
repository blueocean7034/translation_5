/*
 * Pseudo C translation of the second portion of assembly.txt
 * Continuation after address 0x0067. This is a best effort
 * translation of 6502 instructions to C-like pseudocode. Hardware
 * specific operations are represented as memory accesses to absolute
 * addresses. Flags and CPU state are not fully emulated.
 */

#include <stdint.h>
#include <stdbool.h>

// Emulated memory
uint8_t mem[0x10000];

// CPU registers
uint8_t A = 0, X = 0, Y = 0, SP = 0;
uint16_t PC = 0x006A;  // start of this portion
bool interrupt_disable = false;

void routine_part2(void) {
    // 0x006A: ORA ($A4,X)
    {
        uint16_t addr = mem[(uint8_t)(0xA4 + X)] | (mem[(uint8_t)(0xA4 + X + 1)] << 8);
        A |= mem[addr];
    }

    // 0x006C: INY
    Y++;

    // 0x006D: CPX $0010 (flags ignored)
    (void)mem[0x0010];

    // 0x0070: EOR ($41,X)
    {
        uint16_t addr = mem[(uint8_t)(0x41 + X)] | (mem[(uint8_t)(0x41 + X + 1)] << 8);
        A ^= mem[addr];
    }

    // 0x0072: JMP $3C34
    PC = 0x3C34; // jump to new location
}

/*
 * Bytes from 0x0075 to 0x0090 appear to be data or unused opcodes and are
 * not translated here.
 */

void subroutine_0092(void) {
    // 0x0092: LDA $0778
    A = mem[0x0778];
    // 0x0095: AND #$7F
    A &= 0x7F;
    // 0x0097: STA $0778
    mem[0x0778] = A;
    // 0x009A: AND #$7E
    A &= 0x7E;
    // 0x009C: STA $2000
    mem[0x2000] = A;

    // 0x009F: LDA $0779
    A = mem[0x0779];
    // 0x00A2: AND #$E6
    A &= 0xE6;
    // 0x00A4: LDY $0774
    Y = mem[0x0774];
    // 0x00A7: BNE $00AE
    if (Y == 0) {
        // 0x00A9: LDA $0779
        A = mem[0x0779];
        // 0x00AC: ORA #$1E
        A |= 0x1E;
    }
    // 0x00AE: STA $0779
    mem[0x0779] = A;

    // 0x00B1: AND #$E7
    A &= 0xE7;
    // 0x00B3: STA $2001
    mem[0x2001] = A;

    // 0x00B6: LDX $2002
    X = mem[0x2002];
    // 0x00B9: LDA #$00
    A = 0x00;
    // 0x00BB: JSR $8EE6
    // 0x00BE: STA $2003
    mem[0x2003] = A;
    // 0x00C1: LDA #$02
    A = 0x02;
    // 0x00C3: STA $4014
    mem[0x4014] = A;

    // 0x00C6: LDX $0773
    X = mem[0x0773];
    // 0x00C9: LDA $805A,X
    A = mem[0x805A + X];
    // 0x00CC: STA $00
    mem[0x0000] = A;
    // 0x00CE: LDA $806D,X
    A = mem[0x806D + X];
    // 0x00D1: STA $01
    mem[0x0001] = A;

    // 0x00D3: JSR $8EDD
    // 0x00D6: LDY #$00
    Y = 0x00;
    // 0x00D8: LDX $0773
    X = mem[0x0773];
    // 0x00DB: CPX #$06
    if (X == 0x06) {
        // 0x00DF: INY
        Y++;
    }
    // 0x00E0: LDX $8080,Y
    X = mem[0x8080 + Y];
    // 0x00E3: LDA #$00
    A = 0x00;
    // 0x00E5: STA $0300,X
    mem[0x0300 + X] = A;
    // 0x00E8: STA $0301,X
    mem[0x0301 + X] = A;
    // 0x00EB: STA $0773
    mem[0x0773] = A;

    // 0x00EE: LDA $0779
    A = mem[0x0779];
    // 0x00F1: STA $2001
    mem[0x2001] = A;

    // 0x00F4: JSR $F2D0
    // 0x00F7: JSR $8E5C
    // 0x00FA: JSR $8182
    // 0x00FD: JSR $8F97

    // 0x0100: LDA $0776
    A = mem[0x0776];
    // 0x0103: LSR
    A >>= 1;
    // 0x0104: BCS $012B (carry from LSR)
    bool carry = A & 0x01;
    if (carry) {
        goto branch_012B;
    }

    // 0x0106: LDA $0747
    A = mem[0x0747];
    // 0x0109: BEQ $0110
    if (A == 0) {
        goto branch_0110;
    }
    // 0x010B: DEC $0747
    mem[0x0747]--;
    // 0x010E: BNE $0129
    if (mem[0x0747] != 0) {
        goto branch_0129;
    }
branch_0110:
    // 0x0110: LDX #$14
    X = 0x14;
    // 0x0112: DEC $077F
    mem[0x077F]--;
    // 0x0115: BPL $011E
    if ((int8_t)mem[0x077F] < 0) {
        // 0x0117: LDA #$14
        A = 0x14;
        // 0x0119: STA $077F
        mem[0x077F] = A;
        // 0x011C: LDX #$23
        X = 0x23;
    }
branch_011E:
    // 0x011E: LDA $0780,X
    A = mem[0x0780 + X];
    // 0x0121: BEQ $0126
    if (A == 0) {
        // nothing
    } else {
        // 0x0123: DEC $0780,X
        mem[0x0780 + X]--;
    }
    // 0x0126: DEX
    X--;
    // 0x0127: BPL $011E
    if ((int8_t)X >= 0) {
        goto branch_011E;
    }
branch_0129:
    // 0x0129: INC $09
    mem[0x0009]++;
branch_012B:
    // 0x012B: LDX #$00
    X = 0x00;
    // 0x012D: LDY #$07
    Y = 0x07;
    do {
        // 0x012F: LDA $07A7
        A = mem[0x07A7];
        // 0x0132: AND #$02
        A &= 0x02;
        // 0x0134: STA $00
        mem[0x0000] = A;
        // 0x0136: LDA $07A8
        A = mem[0x07A8];
        // 0x0139: AND #$02
        A &= 0x02;
        // 0x013B: EOR $00
        A ^= mem[0x0000];
        // 0x013D: CLC / 0x013E: BEQ $0141
        if (A != 0) {
            // 0x0140: SEC (ignored)
        }
        // 0x0141: ROR $07A7,X (carry ignored)
        {
            uint8_t val = mem[0x07A7 + X];
            val >>= 1;
            mem[0x07A7 + X] = val;
        }
        // 0x0144: INX
        X++;
        // 0x0145: DEY
        Y--;
        // 0x0146: BNE $0141
    } while (Y != 0);

    // 0x0148: LDA $0722
    A = mem[0x0722];
    // 0x014B: BEQ $016C
    if (A == 0) {
        goto branch_016C;
    }
    do {
        // 0x014D: LDA $2002
        A = mem[0x2002];
        // 0x0150: AND #$40
        A &= 0x40;
        // 0x0152: BNE $014D
    } while (A != 0);

    // 0x0154: LDA $0776
    A = mem[0x0776];
    // 0x0157: LSR
    A >>= 1;
    // 0x0158: BCS $0160
    if (A & 0x01) {
        goto branch_0160;
    }
    // 0x015A: JSR $8223
    // 0x015D: JSR $81C6
branch_0160:
    // 0x0160: LDA $2002
    A = mem[0x2002];
    do {
        // 0x0163: AND #$40
        A &= 0x40;
        // 0x0165: BEQ $0160
        if (A != 0) break;
        A = mem[0x2002];
    } while (true);

    // 0x0167: LDY #$14
    Y = 0x14;
    do {
        // 0x0169: DEY
        Y--;
        // 0x016A: BNE $0169
    } while (Y != 0);
branch_016C:
    // 0x016C: LDA $073F
    A = mem[0x073F];
    // 0x016F: STA $2005
    mem[0x2005] = A;
    // 0x0172: LDA $0740
    A = mem[0x0740];
    // 0x0175: STA $2005
    mem[0x2005] = A;
    // 0x0178: LDA $0778
    A = mem[0x0778];
    // 0x017B: PHA
    mem[0x0100 + SP--] = A;
    // 0x017C: STA $2000
    mem[0x2000] = A;
    // 0x017F: LDA $0776
    A = mem[0x0776];
    // 0x0182: LSR
    A >>= 1;
    // 0x0183: BCS $0188
    if (A & 0x01) {
        goto branch_0188;
    }
    // 0x0185: JSR $8212
branch_0188:
    // 0x0188: LDA $2002
    A = mem[0x2002];
    // 0x018B: PLA
    A = mem[0x0100 + ++SP];
    // 0x018C: ORA #$80
    A |= 0x80;
    // 0x018E: STA $2000
    mem[0x2000] = A;
    // 0x0191: RTI
}
