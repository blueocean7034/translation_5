/*
 * Pseudo-C translation of assembly.txt (addresses 0x005A - 0x0181)
 * This is a first pass and focuses on the direct semantics of each
 * instruction. Hardware registers are represented as memory accesses.
 */

#include <stdint.h>

#define MEM(addr) (*(volatile uint8_t*)(addr))

void routine_part2(void) {
    uint8_t A = 0;
    uint8_t X = 0;
    uint8_t Y = 0;

    /* 0x005A: ORA ($a4,X) */
    {
        uint16_t addr = MEM(0x00A4 + X) | (MEM(0x00A4 + X + 1) << 8);
        A |= MEM(addr);
    }

    /* 0x005C: INY */
    Y++;

    /* 0x005D: CPX $0010 */
    // compare X with MEM(0x0010)

    /* 0x0060: EOR ($41,X) */
    {
        uint16_t addr = MEM(0x0041 + X) | (MEM(0x0041 + X + 1) << 8);
        A ^= MEM(addr);
    }

    /* 0x0062: JMP $3c34 */
    goto addr_3c34;

    /* 0x0065: ??? - unknown opcode */
    // not translated

    /* 0x0066: ??? - unknown opcode */
    // not translated

    /* 0x0067: PLA */
    // pull from stack into A (not modeled)

    /* 0x0068: ??? - unknown opcode */
    // not translated

    /* 0x0069: TAY */
    Y = A;

    /* 0x006A: ??? - unknown opcode */
    // not translated

    /* 0x006B: DEC $03ef,X */
    MEM(0x03EF + X)--;

    /* 0x006E: STY $8c8c */
    MEM(0x8C8C) = Y;

    /* 0x0071: STA $0303 */
    MEM(0x0303) = A;

    /* 0x0074: ??? - unknown opcode */
    // not translated

    /* 0x0075: STA $8d8d */
    MEM(0x8D8D) = A;

    /* 0x0078: STA $8d8d */
    MEM(0x8D8D) = A;

    /* 0x007B: STA $8d8d */
    MEM(0x8D8D) = A;

    /* 0x007E: STA $008d */
    MEM(0x008D) = A;

    /* 0x0081: RTI */
    // return from interrupt

addr_0082:
    /* 0x0082: LDA $0778 */
    A = MEM(0x0778);
    /* 0x0085: AND #$7f */
    A &= 0x7F;
    /* 0x0087: STA $0778 */
    MEM(0x0778) = A;
    /* 0x008A: AND #$7e */
    A &= 0x7E;
    /* 0x008C: STA $2000 */
    MEM(0x2000) = A;
    /* 0x008F: LDA $0779 */
    A = MEM(0x0779);
    /* 0x0092: AND #$e6 */
    A &= 0xE6;
    /* 0x0094: LDY $0774 */
    Y = MEM(0x0774);
    /* 0x0097: BNE $009e */
    if (Y != 0) goto addr_009e;
    /* 0x0099: LDA $0779 */
    A = MEM(0x0779);
    /* 0x009C: ORA #$1e */
    A |= 0x1E;
addr_009e:
    /* 0x009E: STA $0779 */
    MEM(0x0779) = A;
    /* 0x00A1: AND #$e7 */
    A &= 0xE7;
    /* 0x00A3: STA $2001 */
    MEM(0x2001) = A;
    /* 0x00A6: LDX $2002 */
    X = MEM(0x2002);
    /* 0x00A9: LDA #$00 */
    A = 0x00;
    /* 0x00AB: JSR $8ee6 */
    // subroutine at 0x8EE6
    /* 0x00AE: STA $2003 */
    MEM(0x2003) = A;
    /* 0x00B1: LDA #$02 */
    A = 0x02;
    /* 0x00B3: STA $4014 */
    MEM(0x4014) = A;
    /* 0x00B6: LDX $0773 */
    X = MEM(0x0773);
    /* 0x00B9: LDA $805a,X */
    A = MEM(0x805A + X);
    /* 0x00BC: STA $00 */
    MEM(0x0000) = A;
    /* 0x00BE: LDA $806d,X */
    A = MEM(0x806D + X);
    /* 0x00C1: STA $01 */
    MEM(0x0001) = A;
    /* 0x00C3: JSR $8edd */
    // subroutine at 0x8EDD
    /* 0x00C6: LDY #$00 */
    Y = 0x00;
    /* 0x00C8: LDX $0773 */
    X = MEM(0x0773);
    /* 0x00CB: CPX #$06 */
    // sets flags based on X - 0x06
    /* 0x00CD: BNE $00d0 */
    if (X != 0x06) goto addr_00d0;
    /* 0x00CF: INY */
    Y++;
addr_00d0:
    /* 0x00D0: LDX $8080,Y */
    X = MEM(0x8080 + Y);
    /* 0x00D3: LDA #$00 */
    A = 0x00;
    /* 0x00D5: STA $0300,X */
    MEM(0x0300 + X) = A;
    /* 0x00D8: STA $0301,X */
    MEM(0x0301 + X) = A;
    /* 0x00DB: STA $0773 */
    MEM(0x0773) = A;
    /* 0x00DE: LDA $0779 */
    A = MEM(0x0779);
    /* 0x00E1: STA $2001 */
    MEM(0x2001) = A;
    /* 0x00E4: JSR $f2d0 */
    // subroutine at 0xF2D0
    /* 0x00E7: JSR $8e5c */
    // subroutine at 0x8E5C
    /* 0x00EA: JSR $8182 */
    // subroutine at 0x8182
    /* 0x00ED: JSR $8f97 */
    // subroutine at 0x8F97
    /* 0x00F0: LDA $0776 */
    A = MEM(0x0776);
    /* 0x00F3: LSR A */
    A >>= 1;
    /* 0x00F4: BCS $011b */
    // if carry set, goto addr_011b
    /* 0x00F6: LDA $0747 */
    A = MEM(0x0747);
    /* 0x00F9: BEQ $0100 */
    if (A == 0) goto addr_0100;
    /* 0x00FB: DEC $0747 */
    MEM(0x0747)--;
    /* 0x00FE: BNE $0119 */
    if (MEM(0x0747) != 0) goto addr_0119;
addr_0100:
    /* 0x0100: LDX #$14 */
    X = 0x14;
    /* 0x0102: DEC $077f */
    MEM(0x077F)--;
    /* 0x0105: BPL $010e */
    if ((int8_t)MEM(0x077F) >= 0) goto addr_010e;
    /* 0x0107: LDA #$14 */
    A = 0x14;
    /* 0x0109: STA $077f */
    MEM(0x077F) = A;
    /* 0x010C: LDX #$23 */
    X = 0x23;
addr_010e:
    /* 0x010E: LDA $0780,X */
    A = MEM(0x0780 + X);
    /* 0x0111: BEQ $0116 */
    if (A == 0) goto addr_0116;
    /* 0x0113: DEC $0780,X */
    MEM(0x0780 + X)--;
addr_0116:
    /* 0x0116: DEX */
    X--;
    /* 0x0117: BPL $010e */
    if ((int8_t)X >= 0) goto addr_010e;
addr_0119:
    /* 0x0119: INC $09 */
    MEM(0x0009)++;
addr_011b:
    /* 0x011B: LDX #$00 */
    X = 0x00;
    /* 0x011D: LDY #$07 */
    Y = 0x07;
    /* 0x011F: LDA $07a7 */
    A = MEM(0x07A7);
    /* 0x0122: AND #$02 */
    A &= 0x02;
    /* 0x0124: STA $00 */
    MEM(0x0000) = A;
    /* 0x0126: LDA $07a8 */
    A = MEM(0x07A8);
    /* 0x0129: AND #$02 */
    A &= 0x02;
    /* 0x012B: EOR $00 */
    A ^= MEM(0x0000);
    /* 0x012D: CLC */
    // clear carry
    /* 0x012E: BEQ $0131 */
    if (A == 0) goto addr_0131;
    /* 0x0130: SEC */
    // set carry
addr_0131:
    /* 0x0131: ROR $07a7,X */
    // rotate right with carry on MEM(0x07A7 + X)
    /* 0x0134: INX */
    X++;
    /* 0x0135: DEY */
    Y--;
    /* 0x0136: BNE $0131 */
    if (Y != 0) goto addr_0131;
    /* 0x0138: LDA $0722 */
    A = MEM(0x0722);
    /* 0x013B: BEQ $015c */
    if (A == 0) goto addr_015c;
addr_013d:
    /* 0x013D: LDA $2002 */
    A = MEM(0x2002);
    /* 0x0140: AND #$40 */
    A &= 0x40;
    /* 0x0142: BNE $013d */
    if (A != 0) goto addr_013d;
    /* 0x0144: LDA $0776 */
    A = MEM(0x0776);
    /* 0x0147: LSR A */
    A >>= 1;
    /* 0x0148: BCS $0150 */
    // if carry set, goto addr_0150
    /* 0x014A: JSR $8223 */
    // subroutine at 0x8223
    /* 0x014D: JSR $81c6 */
    // subroutine at 0x81C6
addr_0150:
    /* 0x0150: LDA $2002 */
    A = MEM(0x2002);
    /* 0x0153: AND #$40 */
    A &= 0x40;
    /* 0x0155: BEQ $0150 */
    if (A == 0) goto addr_0150;
    /* 0x0157: LDY #$14 */
    Y = 0x14;
addr_0159:
    /* 0x0159: DEY */
    Y--;
    /* 0x015A: BNE $0159 */
    if (Y != 0) goto addr_0159;
addr_015c:
    /* 0x015C: LDA $073f */
    A = MEM(0x073F);
    /* 0x015F: STA $2005 */
    MEM(0x2005) = A;
    /* 0x0162: LDA $0740 */
    A = MEM(0x0740);
    /* 0x0165: STA $2005 */
    MEM(0x2005) = A;
    /* 0x0168: LDA $0778 */
    A = MEM(0x0778);
    /* 0x016B: PHA */
    // push A to stack (not modeled)
    /* 0x016C: STA $2000 */
    MEM(0x2000) = A;
    /* 0x016F: LDA $0776 */
    A = MEM(0x0776);
    /* 0x0172: LSR A */
    A >>= 1;
    /* 0x0173: BCS $0178 */
    // if carry set, goto addr_0178
    /* 0x0175: JSR $8212 */
    // subroutine at 0x8212
addr_0178:
    /* 0x0178: LDA $2002 */
    A = MEM(0x2002);
    /* 0x017B: PLA */
    // pull from stack into A (not modeled)
    /* 0x017C: ORA #$80 */
    A |= 0x80;
    /* 0x017E: STA $2000 */
    MEM(0x2000) = A;
    /* 0x0181: RTI */
    // return from interrupt
}

addr_3c34:
    // placeholder for external jump target
